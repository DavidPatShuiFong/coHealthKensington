---
title: "Daily View"
author: "&copy; 2019 David Fong"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    includes:
      in_header: 'fomantic_ui.html'
    
runtime: shiny

---

```{r global, setup, include=FALSE}
library(flexdashboard)
library(shinyjs)
library(tidyverse)

library(dbplyr) # database interaction for dplyr
library(DBI)    # R database interface
library(odbc)   # the database backend handler for Microsoft SQL Server
library(pool)   # database pool

library(base64enc)  # simple obfuscation for passwords
library(DT)         # pretty-print tables/tibbles
library(lubridate)  # time handling library

# database setup

filename <- 'BestPracticeSQL_password.txt'
dbpassword <- rawToChar(base64decode(readChar(filename,file.info(filename)$size)))
  # obfuscated, NOT ENCRYPTED, password
  # password file created with command like
  #    cat(base64encode(charToRaw('mypassword')), file="BestPracticeSQL_password.txt")

pool <- dbPool(odbc::odbc(), driver = "SQL Server", server = "127.0.0.1\\BPSINSTANCE", 
                      database = "BPSSamples", uid = "bpsrawdata", pwd = dbpassword)

practice_locations <- as.tibble(read.csv('PracticeLocations.csv'))
  # two columns : 'Fullname' and 'Location'

# database table setup

users <- pool %>% 
  tbl(in_schema('dbo', 'BPS_Users')) %>% 
  select(c('UserID', 'Surname', 'Firstname', 'LocationName', 'Title')) %>%
  collect() %>%     # forces database to be read (instead of subsequent 'lazy' read)
  mutate(Title = trimws(Title), Firstname = trimws(Firstname), Surname = trimws(Surname)) %>%
  mutate(Fullname = paste(Title, Firstname, Surname, sep = ' ')) %>%
  left_join(practice_locations) %>%   # add practice locations imported from external CSV file
  filter(!is.na(Location))            # only include users which have a defined practice location

locations <- rbind(tibble(Location = 'All'), practice_locations %>% select(c('Location')) %>% unique()) 
  # add 'All' to (unique) locations list

patients <- pool %>%
  tbl(in_schema('dbo', 'BPS_Patients'))

investigations <- pool %>%            
  tbl(in_schema('dbo', 'BPS_Investigations')) %>%
  select(c('InternalID', 'Collected', 'TestName'))
  # as of Jan/2019, the odbc engine for MSSQL can't handle the full ('Select *') Investigations table
  # due to some type of bug/standards non-compliance. also can handle the History table. need to
  # 'Select' out just a few columns.

immunizations <- pool %>%
  tbl(in_schema('dbo', 'BPS_Immunisations')) %>%
  select(c('InternalID', 'GivenDate', 'VaccineName', 'VaccineID'))

correspondenceIn <- pool %>%
  tbl(in_schema('dbo', 'BPS_CorrespondenceIn')) %>%
  select(c('InternalID', 'CorrespondenceDate', 'Subject', 'Detail'))

reportValues <- pool %>%
  tbl(in_schema('dbo', 'BPS_ReportValues')) %>%
  select(c('InternalID', 'ReportDate', 'ResultName', 'LoincCode'))

invoices <- pool %>%
  tbl(in_schema('dbo', 'INVOICES')) %>%
  select(c('InternalID', 'INVOICEID', 'INVOICEDATE'))

services <- pool %>%
  tbl(in_schema('dbo', 'BPS_SERVICES'))

# function setup

# fomantic (semantic.ui) string functions

semantic_tag <- function(tag, colour="", popuptext = NA, popuphtml = NA) {
  # returns a vector of tags. user-defined colour and popuptext (tooltip) or popuphtml (HTMl tooltip)
  # note that 'data-variation' is only available in the fomantic version of semantic.ui
  # as of writing, semantic.ui does not allow variation in text-size of javascript-free tags
  paste0('<span class="huge ', colour, ' ui tag label"',
         ifelse(!is.na(popuphtml),
                paste0('data-variation="wide" data-position = "left center" data-html="',
                       popuphtml,
                       '"', sep=""),
                ''),
         '> ',
         ifelse(!is.na(popuptext),
                paste0('<span data-tooltip = "',
                       popuptext,
                       '" data-variation = "wide huge" data-position = "left center">', sep=""),
                ''),
         tag,
         ifelse(!is.na(popuptext), '</span>', ''),
         ' </span>', sep = "") 
  # paste0 is vectorized version of 'paste'
}

semantic_button <- function(button, colour="", popuptext = NA, popuphtml = NA) {
  # returns a vector of buttons. user-defined colour and popuptext (tooltip) or popuphtml (HTML tooltip)
  # note that 'data-variation' is only available in the fomantic version of semantic.ui
  # as of writing, semantic.ui does not allow variation in text-size of javascript-free tags
  paste0('<span class="huge ', colour, ' ui button"',
         ifelse(!is.na(popuphtml),
                paste0('data-variation="wide" data-position = "left center" data-html="',
                       popuphtml,
                       '"', sep=""),
                ''),
         '> ',
         ifelse(!is.na(popuptext),
                paste0('<span data-tooltip = "',
                       popuptext,
                       '" data-variation = "wide huge" data-position = "left center">', sep=""),
                ''),
         button,
         ifelse(!is.na(popuptext), '</span>', ''),
         ' </span>', sep = "") 
  # paste0 is vectorized version of 'paste'
}

## datatables functions and definitions

semantic_popupJS <- c("window.onload = function() {$('.ui.button') .popup({on: 'hover'});
                      $('.ui.tag.label') .popup({on: 'hover'})
                      }")
# (1) necessary for semantic/fomantic JS popups. included directly in datatables options
# (2) provide padding for export/print buttons

datatable_styled <- function(data, fillContainer = TRUE,
                             extensions = c('Buttons', 'Scroller'),
                             options=list(dom = 'frltiBp',
                                        buttons = c('copyHtml5', 'csvHtml5', 'excel', 'pdf', 'print'),
                                        initComplete = JS(semantic_popupJS),
                                        paging = FALSE),
                             ...) {
  datatable(data, fillContainer = fillContainer, extensions = extensions, options = options, ... )
}
# by default, have export/print buttons, only render what is visible
# javascript code to attach labels to semantic/fomantic JS popups
# no pagination

```

Inputs {.sidebar}
-----------------------------------------------------------------------

### Appointment Date Range

```{r}
wellPanel(
  useShinyjs(rmd = TRUE),

  dateInput('date1', label = 'From:', format='D dd/M/yyyy', min = Sys.Date()-4000, max = Sys.Date()+180),
  dateInput('date2', label = 'To:', format='D dd/M/yyyy', min = Sys.Date()-4000, max = Sys.Date()+180),
  actionButton('update_date', 'Update', icon('refresh'), class = 'btn btn-primary'),
  helpText("After adjusting the date range, click the 'Update' button",
           "to adjust the viewed appointment date range"),
  tags$div(title = "View today's appointments",
           actionButton('update_date_today', 'Today', icon('calendar'), class = 'btn btn-info'))
)

```

### Clinician list

```{r}
wellPanel(
  selectInput('location', 'Practice location', locations, selected = 'All'),
  uiOutput('clinicianList'),
  tags$div(title = "Select/De-select all clinicians",
           actionButton('toggle_clinician_list', 'Select All/None', icon('check-square'), class = 'btn btn-primary'))
)

```

```{r}
# 'helper' functions for input panel

# only adjust appointment view after dates are 'submitted'
date_a <- eventReactive(input$update_date, {
  input$date1
}, ignoreNULL = FALSE) # initialize on first run, after that only update if 'update' button used
date_b <- eventReactive(input$update_date, {
  input$date2
}, ignoreNULL = FALSE)

date_today <- observeEvent(input$update_date_today, {
  updateDateInput(session, 'date1', value = Sys.Date())
  updateDateInput(session, 'date2', value = Sys.Date())
  click('update_date')
})

# list of clinicians shown depends on 'practice location' chosen
clinician_choice_list <- reactive({
  if (input$location == 'All') users$Fullname else users[users$Location == input$location,]$Fullname
  # note that 'ifelse' only returns result in the same 'shape' as the comparison statement
})

output$clinicianList <- renderUI({
  choice_list <- clinician_choice_list()
  chosen_list <- input$clinicians # retain previous selections
  checkboxGroupInput('clinicians', label = 'Clinician', choices = choice_list, selected = chosen_list)
})

toggle_clinicians <- observeEvent(input$toggle_clinician_list, {
  if (input$toggle_clinician_list == 0) {return(NULL)}
  else if (input$toggle_clinician_list%%2 == 1) {
    updateCheckboxGroupInput(session, 'clinicians', selected = clinician_choice_list())
    # toggle all clinicians selected
  } else {
    updateCheckboxGroupInput(session, 'clinicians', selected = character(0))
    # no clinicians selected
  }
})

```

```{r}
# 'helper' functions for calculation

calc_age <- function(birthDate, refDate = Sys.Date()) {
  # Calculate age at a given reference date
  # Create an interval between the date of birth and the enrollment date; 
  # intervals are specific to the two dates. Periods give the actual length
  # of time between those dates, so convert to period and extract the year.
  # written by 'mmparker' https://gist.github.com/mmparker/7254445

  period <- as.period(interval(birthDate, refDate),                        
                      unit = "year")
  period$year
}
```

Row {.tabset}
-----------------------------------------------------------------------

### Daily Measure

```{r}
zostavax_immunization_query <-paste("SELECT InternalID, GivenDate, VaccineName FROM dbo.BPS_Immunisations
                                     WHERE ((VaccineName LIKE '%zostavax%') OR (VaccineID=103))
                                     AND InternalID NOT IN (SELECT InternalID
                                     FROM dbo.Preventivehealth
                                     WHERE itemid=15)")
# either then name is 'like' Zostavax (this is needed where vaccines have been imported from Medical Director)
# or the specific Zostavax ID in Best Practice
# and excluding those who have been excluded from Zostavax reminders (itemid=15)

zostavax_vax_list <- reactive({
  appointment_list() %>%
    filter(Age>=70 & Age<=80) %>% # from age 70 to 80 years inclusive
    left_join(dbGetQuery(pool, zostavax_immunization_query) %>% collect(),
              by = 'InternalID')
})

renderDT({datatable_styled(zostavax_vax_list())})

```

### Daily Measure 2

```{r}

bowel_cancer_screen_terms <- c("(VALUES('%FOB%'), ('%OCCULT%'), ('%FAECAL HUMAN HAEMOGLOBIN%'),
                               ('%OCB NATIONAL SCREENING%'), ('%FHB%'), ('%FAECAL BLOOD%'),
                               ('%FAECAL IMMUNOCHEMICAL TEST%'), ('%FAECAL HAEMOGLOBIN%'),
                               ('%COLONOSCOPY%'), ('%COLONOSCOPE%')) AS tests(fobtnames)")

fobt_investigation_query <- paste('SELECT InternalID, Collected, TestName FROM dbo.BPS_Investigations
                                    INNER JOIN', bowel_cancer_screen_terms,
                                    'ON TestName LIKE tests.fobtnames')
    # SQL code to find investigations which could be bowel cancer screening items

fobt_letter_subject_query <- paste('SELECT InternalID, CorrespondenceDate, Subject FROM dbo.BPS_CorrespondenceIn
                                   INNER JOIN', bowel_cancer_screen_terms,
                                  'ON Subject LIKE tests.fobtnames')

fobt_letter_detail_query <- paste('SELECT InternalID, CorrespondenceDate, Detail FROM dbo.BPS_CorrespondenceIn
                                  INNER JOIN', bowel_cancer_screen_terms,
                                  'ON Detail LIKE tests.fobtnames')

fobt_result_query <- paste("SELECT InternalID, ReportDate, ResultName FROM dbo.BPS_ReportValues 
                           WHERE LoincCode IN ('2335-8','27396-1','14563-1','14564-9','14565-6',
                         	                     '12503-9','12504-7','27401-9','27925-7','27926-5',
	                                             '57905-2','56490-6','56491-4','29771-3')")

screen_fobt_list <- reactive({
  appointment_list() %>%
    filter(Age >= 50 & Age <=75) # from age 50 to 75 years inclusive
})

screen_fobt_ix <- reactive({
  left_join(screen_fobt_list(),
            bind_rows(inner_join(screen_fobt_list(),
                                 dbGetQuery(pool, fobt_investigation_query) %>% collect() %>%
                                   rename(TestDate = Collected),
                                 by = 'InternalID'),
                      inner_join(screen_fobt_list(),
                                 dbGetQuery(pool, fobt_letter_subject_query) %>% collect() %>%
                                   rename(TestDate = CorrespondenceDate, TestName = Subject),
                                 by = 'InternalID'),
                      inner_join(screen_fobt_list(),
                                 dbGetQuery(pool, fobt_letter_detail_query) %>% collect() %>%
                                   rename(TestDate = CorrespondenceDate, TestName = Detail),
                                 by = 'InternalID'),
                      inner_join(screen_fobt_list(),
                                 dbGetQuery(pool, fobt_result_query) %>% collect() %>%
                                   rename(TestDate = ReportDate, TestName = ResultName),
                                 by = 'InternalID')
                      ) %>%
              mutate(TestDate = as.Date(substr(TestDate, 1, 10))) %>%  # remove time from date
              group_by(InternalID) %>% # group by patient ID (need most recent investigation for each patient)
              filter(TestDate == max(TestDate, na.rm = TRUE))  # only keep the latest(/recent) dated investigation
  )
})

renderDT({
  datatable_styled(screen_fobt_ix() %>%
              
                     mutate(OutOfDateTest = case_when(is.na(TestDate) ~ 1, # if no date (no detected test)
                                                      interval(TestDate, AppointmentDate)>years(2) ~ 2,  # if old
                                                      TRUE ~ 3)) %>%       # if up-to-date
                     replace_na(list(TestName = 'FOBT')) %>%
                     mutate(fobttag = semantic_tag(TestName,
                                                   colour = c('red', 'yellow', 'green')[OutOfDateTest],
                                                   popuphtml = paste0("<h4>Date : ", TestDate, "</h4>"))) %>%
                     select(c('Patient', 'AppointmentDate', 'AppointmentTime', 'Provider', 'DOB', 'Age', 'fobttag')),
                   escape = c(7),
                   colnames = c('FOBT' = 'fobttag')
                   )
  }, server = FALSE)

```

```{r}

# collects ALL billings for patients who have displayed appointments
appointments_billings <- reactive({
  appointment_list() %>%
    left_join(services, by = c('InternalID' = 'INTERNALID'), copy=TRUE) %>%
    collect() %>%
    mutate(SERVICEDATE = as.Date(substr(SERVICEDATE, 1, 10)))
  })

```

### Billing

```{r}
# filter to billings which are done on the same day as displayed appointments
appointments_billings_sameday <- reactive({
  appointments_billings() %>%
    filter(SERVICEDATE == AppointmentDate) %>%    # billings done on the same day as displayed appointments
    select(c('InternalID', 'AppointmentDate', 'AppointmentTime', 'Provider', 'MBSITEM', 'DESCRIPTION')) %>%
    # need to preserve ApppointmentTime and Provider in the case where there are multiple apppointments
    # for the patient in the same time period/day and providers
    mutate(MBSITEM = semantic_button(MBSITEM,
                                     colour = 'green',
                                     popuphtml = paste0('<h4>', AppointmentDate,
                                                        "</h3><p><font size=\'+0\'>",
                                                        DESCRIPTION, '</p>'))) %>%
    # change MBSITEMS into fomantic/semantic tags
    group_by(InternalID, AppointmentDate, AppointmentTime, Provider) %>%     
    # gathers item numbers on the same day into a single row
    summarise(Billings = paste(MBSITEM, collapse = "")) %>%
    ungroup()
  })

renderDT({
  datatable_styled(appointments() %>%
                     left_join(appointments_billings_sameday(),
                       by = c('InternalID', 'AppointmentDate', 'AppointmentTime', 'Provider')) %>%
                     select(c('Patient', 'AppointmentDate', 'AppointmentTime', 'Provider', 'Status', 'Billings')),
                     escape = c(6) # only interpret HTML for last column
  )
}, server = TRUE)

```


### Chronic Disease Management Items

```{r}
cdm_item <- data.frame(
  code = c(721, 723, 732, 703, 705, 707, 2517, 2521, 2525, 2546, 2552, 2558, 2700, 2701, 2715, 2717),
  name = c('GPMP', 'TCA', 'GPMP R/V', 'HA', 'HA', 'HA', 'DiabetesSIP', 'DiabetesSIP', 'DiabetesSIP',
           'AsthmaSIP', 'AsthmaSIP', 'AsthmaSIP', 'MHCP', 'MHCP', 'MHCP', 'MHCP')
  )

# filter to CDM item billed prior to (or on) the day of displayed appointments
# only show most recent billed item in each category

appointments_billings_cdm <- reactive({
    appointments_billings() %>%
    filter(MBSITEM %in% cdm_item$code) %>% # only chronic disease management items
    filter(SERVICEDATE <= AppointmentDate) %>% # only items billed before the appointment day
    select(c('InternalID', 'AppointmentDate', 'AppointmentTime', 'Provider', 'SERVICEDATE', 'MBSITEM', 'DESCRIPTION')) %>%
    mutate(MBSNAME = cdm_item$name[match(MBSITEM, cdm_item$code)]) %>%
    group_by(InternalID, AppointmentDate, AppointmentTime, Provider, MBSNAME) %>%   
    # group by patient, apppointment and CDM type (name)
    filter(SERVICEDATE == max(SERVICEDATE, na.rm = TRUE)) %>% # only keep most recent service
    ungroup() %>%
    mutate(mbstag = semantic_tag(MBSNAME,
                                 colour = ifelse((interval(SERVICEDATE, AppointmentDate)<=years(1)),
                                                 'green',
                                                 'yellow'),
                                 popuphtml = paste0("<h4>Date : ", SERVICEDATE,
                                                    "</h4><h6>Item : ", MBSITEM,
                                                    "</h6><p><font size=\'+0\'>", DESCRIPTION, "</p>")
                                 )) %>%
    group_by(InternalID, AppointmentDate, AppointmentTime, Provider) %>%     
    # gathers item numbers on the same day into a single row
    summarise(cdm = paste(mbstag, collapse = "")) %>%
    ungroup()
  })

renderDT({
  datatable_styled(appointments() %>%
                     inner_join(appointments_billings_cdm(),
                                by = c('InternalID', 'AppointmentDate', 'AppointmentTime', 'Provider')) %>%
                     select(c('Patient', 'AppointmentDate', 'AppointmentTime', 'Provider', 'cdm')),
                   colnames = c('Patient', 'Appointment Date', 'Appointment Time', 'Provider', 'CDM items'),
                   escape = c(5)) # only interpret HTML for last column
  },
  server = TRUE)

```

### Appointments

```{r}

hrmin <- function(t) {
  # converts seconds to a 'time' starting from midnight
  # t : value in seconds
  # returns 24-hour time of form '14:15' (hh:mm)
  td <- seconds_to_period(t)
  sprintf('%02d:%02d', td@hour, td@minute)
}

appointments <- reactive({
  validate (
    need(input$clinicians, 'Choose at least one clinician appointment to view'),
    need(date_a(), 'Invalid date range'),
    need(date_b(), 'Invalid date range')
  )
  pool %>% 
    tbl(in_schema('dbo', 'BPS_Appointments')) %>%
    filter(AppointmentDate >= local(date_a()) & AppointmentDate <= local(date_b())) %>%
    filter(Provider %in% input$clinicians) %>% 
      # note that dbplyr does not evaluate manipulated expressions, hence the use of 'local()'
      # a database filter on an empty list after %in% will result in an error message
    select(c('Patient', 'InternalID', 'AppointmentDate', 'AppointmentTime', 'Provider', 'Status')) %>%
    collect() %>% # force read of database
    mutate(AppointmentTime = hrmin(AppointmentTime), AppointmentDate = as.Date(substr(AppointmentDate,1,10))) %>%
    arrange(AppointmentDate, AppointmentTime)
})

appointment_list <- reactive({
  appointments() %>%
    left_join(patients, by = 'InternalID', copy = TRUE) %>%   # need patients database to access date-of-birth
    select(c('Patient', 'InternalID', 'AppointmentDate', 'AppointmentTime', 'Provider', 'DOB')) %>% 
    mutate(DOB = as.Date(substr(DOB, 1, 10))) %>%
    mutate(Age = calc_age(DOB, AppointmentDate))
  })

renderDT({datatable_styled(
  appointments() %>%
    select(c('Patient', 'AppointmentDate', 'AppointmentTime', 'Provider', 'Status')))
  },
  server = FALSE)

```

### Test

```{r}
a <- data.frame(a=c(2,3,68),
                b=c('<span class="huge green positive ui tag label"><span data-tooltip="check me" data-variation="huge">721</span></span><span class="huge green positive ui tag label">723</span><span class="ui tag label">10990</span>',
                    '<div class="huge ui negative button" data-tooltip="waiting ... "><i class="wheelchair loading icon"></i>2715</div>',
                    '<div class="huge ui button positive" data-variation="wide" data-html="<h1>Cheese factory</h1><font size=\'+0\'><b>Lots and lots</b> of information. make sure everything is <ins>complete</ins> on year after ... 12/Jan/2019</font>">GPMP</div>'
                    ))
               
renderDT({datatable(a,
                    options = list(initComplete = JS(semantic_popupJS)),
                    escape = FALSE)})
```
